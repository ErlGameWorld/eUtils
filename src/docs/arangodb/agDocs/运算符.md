经营者
AQL支持许多可在表达式中使用的运算符。有比较，逻辑，算术和三元运算符。

比较运算符
比较（或关系）运算符比较两个操作数。它们可以与任何输入数据类型一起使用，并将返回布尔结果值。

支持以下比较运算符：

操作员	描述
==	平等
!=	不等式
<	少于
<=	小于或等于
>	比...更棒
>=	大于或等于
IN	测试值是否包含在数组中
NOT IN	测试值是否不包含在数组中
LIKE	测试字符串值是否与模式匹配
NOT LIKE	测试字符串值是否与模式不匹配
=~	测试字符串值是否与正则表达式匹配
!~	测试字符串值是否与正则表达式不匹配
如果可以评估比较结果，则每个比较运算符都将返回一个布尔值；如果比较结果为true，则返回true；否则返回false 。

比较运算符接受第一和第二操作数的任何数据类型。但是，IN并且NOT IN仅在其右侧操作数是数组的情况下才会返回有意义的结果。LIKE并且NOT LIKE仅在两个操作数均为字符串值时才执行。如果比较的操作数具有不同或不合理的类型，则比较运算符将不执行任何隐式类型转换。

AQL中比较操作的一些示例：

     0  ==  null            // false
     1  >   0               // true
  true  !=  null            // true
    45  <=  "yikes!"        // true
    65  !=  "65"            // true
    65  ==  65              // true
  1.23  >   1.32            // false
   1.5  IN  [ 2, 3, 1.5 ]   // true
 "foo"  IN  null            // false
42  NOT IN  [ 17, 40, 50 ]  // true
 "abc"  ==  "abc"           // true
 "abc"  ==  "ABC"           // false
 "foo"  LIKE  "f%"          // true
 "foo"  NOT LIKE  "f%"      // false
 "foo"  =~  "^f[o].$"       // true
 "foo"  !~  "[a-z]+bar$"    // true
该LIKE运营商检查是否其左操作数以其右操作数指定的模式相匹配。该模式可以包含常规字符和通配符。支持的通配符_将匹配单个任意字符，并%匹配任意数量的任意字符。文字%，_需要以反斜杠转义。反斜杠需要自己转义，这实际上意味着两个反斜线字符必须在文字百分号或下划线之前。在arangosh中，需要进行额外的转义，使其在要转义的字符之前总共加四个反斜杠。

    "abc" LIKE "a%"          // true
    "abc" LIKE "_bc"         // true
"a_b_foo" LIKE "a\\_b\\_foo" // true
LIKE操作员执行的模式匹配区分大小写。

该NOT LIKE经营者具有相同特性的LIKE运营商，但与否定的结果。因此，它与相同NOT (… LIKE …)。请注意括号，这对于某些表达式是必需的：

FOR doc IN coll
  RETURN NOT doc.attr LIKE "…"
return表达式将转换为LIKE(!doc.attr, "…")，从而产生意外结果。NOT(doc.attr LIKE "…")变得更加合理! LIKE(doc.attr, "…")。

正则表达式运算符=~并!~期望它们的左手操作数是字符串，而期望它们的右手操作数是包含有效的正则表达式的字符串，如AQL函数REGEX_TEST（）的文档中所指定 。

数组比较运算符
比较运算符也作为数组变量存在。在阵列变型中，操作者的前缀的关键字之一ALL，ANY 或NONE。使用这些关键字之一可以更改操作员的行为，以便对其所有，任何或不使用其左手参数值执行比较操作。因此，期望数组运算符的左手参数是一个数组。

例子：

[ 1, 2, 3 ]  ALL IN  [ 2, 3, 4 ]  // false
[ 1, 2, 3 ]  ALL IN  [ 1, 2, 3 ]  // true
[ 1, 2, 3 ]  NONE IN  [ 3 ]       // false
[ 1, 2, 3 ]  NONE IN  [ 23, 42 ]  // true
[ 1, 2, 3 ]  ANY IN  [ 4, 5, 6 ]  // false
[ 1, 2, 3 ]  ANY IN  [ 1, 42 ]    // true
[ 1, 2, 3 ]  ANY ==  2            // true
[ 1, 2, 3 ]  ANY ==  4            // false
[ 1, 2, 3 ]  ANY >  0             // true
[ 1, 2, 3 ]  ANY <=  1            // true
[ 1, 2, 3 ]  NONE <  99           // false
[ 1, 2, 3 ]  NONE >  10           // true
[ 1, 2, 3 ]  ALL >  2             // false
[ 1, 2, 3 ]  ALL >  0             // true
[ 1, 2, 3 ]  ALL >=  3            // false
["foo", "bar"]  ALL !=  "moo"     // true
["foo", "bar"]  NONE ==  "bar"    // false
["foo", "bar"]  ANY ==  "foo"     // true
请注意，这些运算符尚未优化。索引将不被使用。

逻辑运算符
AQL支持以下逻辑运算符：

&& 逻辑与运算符
|| 逻辑或运算符
! 逻辑非/否定运算符
AQL还支持逻辑运算符的以下替代形式：

AND 逻辑与运算符
OR 逻辑或运算符
NOT 逻辑非/否定运算符
替代形式是别名，在功能上等同于常规运算符。

AQL中的两个操作数逻辑运算符将使用短路求值执行（除非其中一个操作数是子查询或包含子查询。在这种情况下，子查询将在逻辑运算符之前被提取一个求值）。

AQL中逻辑运算符的结果定义如下：

lhs && rhslhs如果是false或将false转换为布尔值时将返回。如果将lhsis true或be true转换为布尔值， rhs则将返回。
lhs || rhslhs如果是true或将true转换为布尔值时将返回。如果将lhsis false或be false转换为布尔值， rhs则将返回。
! value将返回value转换为布尔值的取反值
AQL中逻辑操作的一些示例：

u.age > 15 && u.address.city != ""
true || false
NOT u.isInvalid
1 || ! 0
允许将非布尔值传递给逻辑运算符。任何非布尔操作数都将由运算符隐式转换为布尔值，而不会使查询中止。

在一个布尔值转换的工作原理如下：

null 将被转换为 false
布尔值保持不变
所有不等于零的数字为true，零为false
空字符串是false，所有其他字符串是true
数组（[ ]）和对象/文档（{ }）是true不论其内容如何
逻辑和与逻辑或运算的结果现在可以具有任何数据类型，并且不一定是布尔值。

例如，以下逻辑运算将返回布尔值：

25 > 1  &&  42 != 7                        // true
22 IN [ 23, 42 ]  ||  23 NOT IN [ 22, 7 ]  // true
25 != 25                                   // false
…，而以下逻辑运算将不会返回布尔值：

   1 || 7                                  // 1
null || "foo"                              // "foo"
null && true                               // null
true && 23                                 // 23
算术运算符
算术运算符对两个数字操作数执行算术运算。算术运算的结果还是一个数值。

AQL支持以下算术运算符：

+ 加成
- 减法
* 乘法
/ 师
% 模数
一元加号和一元减号也受支持：

LET x = -5
LET y = 1
RETURN [-x, +y]
// [5, 1]
为了求幂，有一个数字函数 POW（）。base ** exp不支持语法。

对于字符串连接，必须使用字符串函数 CONCAT（）。将两个字符串与加号（"foo" + "bar"）结合使用将不起作用！另请参阅常见错误。

一些算术运算示例：

1 + 1
33 - 99
12.4 * 4.5
13.0 / 0.1
23 % 7
-15
+9.99
算术运算符接受任何类型的操作数。将非数字值传递给算术运算符将使用TO_NUMBER（）函数应用的类型转换规则将操作数转换为数字：

null 将被转换为 0
false将转换为0，将true转换为1
有效数值保持不变，但NaN和Infinity将转换为 0
如果字符串值包含数字的有效字符串表示形式，则将它们转换为数字。字符串开头或结尾的所有空格都将被忽略。具有其他内容的字符串将转换为数字0
将一个空数组转换为0，将具有一个成员的数组转换为其唯一成员的数字表示形式。具有更多成员的数组将转换为number 0。
对象/文档将转换为数字0。
产生无效值的算术运算，例如1 / 0（除以零）也将产生结果值null。该查询不会终止，但是您可能会看到警告。

这里有一些例子：

   1 + "a"       // 1
   1 + "99"      // 100
   1 + null      // 1
null + 1         // 1
   3 + [ ]       // 3
  24 + [ 2 ]     // 26
  24 + [ 2, 4 ]  // 0
  25 - null      // 25
  17 - true      // 16
  23 * { }       // 0
   5 * [ 7 ]     // 35
  24 / "12"      // 2
   1 / 0         // 0
三元运算符
AQL还支持可用于条件评估的三元运算符。三元运算符期望布尔条件作为其第一个操作数，如果条件的计算结果为true，则返回第二个操作数的结果，否则返回第三个操作数。

例子

u.age > 15 || u.active == true ? u.userId : null
还有只有两个操作数的三元运算符的快捷方式。当布尔条件的表达式和返回值应该相同时，可以使用此变体：

例子

u.value ? : 'value is null, 0 or not present'
范围运算符
AQL支持使用..运算符表达简单的数字范围。该运算符可用于轻松地迭代数字序列。

所述..操作者将产生整数值的阵列在所定义的范围内，与两个边界值包括在内。

例子

2010..2013
将产生以下结果：

[ 2010, 2011, 2012, 2013 ]
使用范围运算符等效于编写一个整数值的数组，该整数值在范围的边界所指定的范围内。如果范围运算符的边界为非整数，则它们将首先转换为整数值。

还有一个RANGE（）函数。

数组运算符
AQL提供阵列运营商[*]为 数组变量扩展和 [**]用于阵列收缩。

运算符优先级
AQL中的运算符优先级与其他熟悉的语言相似（最低优先级优先）：

运营商	描述
,	逗号分隔符
DISTINCT	独特修饰符（返回操作）
? :	三元运算符
=	变量赋值（LET操作）
WITH	与运算符一起（WITH / UPDATE / REPLACE / COLLECT操作）
INTO	进入运算符（INSERT / UPDATE / REPLACE / REMOVE / COLLECT操作）
||	逻辑或
&&	逻辑与
OUTBOUND，INBOUND，ANY，ALL，NONE	图遍历方向，数组比较运算符
==，!=，LIKE，NOT LIKE，=~，!~	（in）相等，通配符（非）匹配，正则表达式（非）匹配
IN， NOT IN	（不是）在运算符中
<，<=，>=，>	小于，小于等于，大于等于，大于
..	范围运算符
+， -	加，减
*，/，%	乘法，除法，模
!，+，-	逻辑否定，一元加，一元减
()	函数调用
.	会员访问
[]	索引值访问
[*]	扩张
::	范围
括号(和)可用于强制执行不同的操作员评估顺序。